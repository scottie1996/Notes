# OOM 异常 (OutOfMemoryError)

[TOC]



## Java 堆溢出

- 出现标志：`java.lang.OutOfMemoryError: Java heap space`
- 解决方法：
	- 先通过内存映像分析工具分析 Dump 出来的堆转储快照，确认内存中的对象是否是必要的，即分清楚是出现了内存泄漏还是内存溢出；
	- 如果是内存泄漏，通过工具查看泄漏对象到 GC Root 的引用链，定位出泄漏的位置；
	- 如果不存在泄漏，检查虚拟机堆参数（-Xmx 和 -Xms）是否可以调大，检查代码中是否有哪些对象的生命周期过长，尝试减少程序运行期的内存消耗。
- 虚拟机参数：
	- `-XX:HeapDumpOnOutOfMemoryError`：让虚拟机在出现内存泄漏异常时 Dump 出当前的内存堆转储快照用于事后分析。



## Java 虚拟机栈和本地方法栈溢出

- 单线程下，栈帧过大、虚拟机容量过小都不会导致 OutOfMemoryError，只会导致 StackOverflowError（栈会比内存先爆掉），一般多线程才会出现 OutOfMemoryError，因为线程本身要占用内存；
- 如果是多线程导致的 OutOfMemoryError，在不能减少线程数或更换 64 位虚拟机的情况，只能通过减少最大堆和减少栈容量来换取更多的线程；
	- 这个调节思路和 Java 堆出现 OOM 正好相反，Java 堆出现 OOM 要调大堆内存的设置值，而栈出现 OOM 反而要调小。



## 方法区和运行时常量池溢出

- 测试思路：产生大量的类去填满方法区，直到溢出；
- 在经常动态生成大量 Class 的应用中，如 Spring 框架（使用 CGLib 字节码技术），方法区溢出是一种常见的内存溢出，要特别注意类的回收状况。



## 直接内存溢出

- 出现特征：Heap Dump 文件中看不见明显异常，程序中直接或间接用了 NIO；
- 虚拟机参数：`-XX:MaxDirectMemorySize`，如果不指定，则和 `-Xmx` 一样。



## 内存泄漏和内存溢出

**内存泄露**本意是申请的内存空间没有被正确释放，导致后续程序里这块内存被永远占用（不可达），而且指向这块内存空间的指针不再存在时，这块内存也就永远不可达了，内存空间就这么一点点被蚕食，借用别人的比喻就是：比如有10张纸，本来一人一张，画完自己擦了还回去，别人可以继续画，现在有个坏蛋要了纸不擦不还，然后还跑了找不到人了，如此就只剩下9张纸给别人用了，这样的人多起来后，最后大家一张纸都没有了。

内存溢出是指**存储的数据超出了指定空间的大小，这时数据就会越界**，举例来说，常见的溢出，是指在栈空间里，分配了超过数组长度的数据，导致多出来的数据覆盖了栈空间其他位置的数据，这种情况发生时，可能会导致程序出现各种难排查的异常行为，或是被有心人利用，修改特定位置的变量数据达到溢出攻击的目的。而Java中的内存溢出，一般指【OOM：发生位置】这种**Error**，它更像是一种内存空间不足时发生的错误，并且也不会导致溢出攻击这种问题，举例来说，堆里能存10个数，分了11个数进去，堆就溢出了1个数，JVM会检测、避免、报告这种问题，所以虽然实际上JVM规避了内存溢出带来的问题，但在概念上来说，它确实是溢出才导致的，只是Java程序员在看到这个问题时，脑袋里的反应会是“内存不够了，咋回事，是不是又是哪个大对象没释放”之类，而不是像C程序员“我X被攻击了/程序咋写的搞溢出了”（这段是我臆想的）。同时对于Java来说，传统意义的溢出攻击也无法奏效，因为Java的数组会检查下标，对超出数组下标的赋值会报ArrayOutOfIndex错误。

而内存泄露的话，个人意见在Java里是不存在的，gc采用根搜索算法时，不可达的对象会被回收，gc是会搜索回收这些空间的，由于程序员个人问题，没用的对象不回收但可达，这种情况能不能界定为内存泄露，我觉得是个哲学问题（对象可达，但空间被占用了，对象也不再使用了），个人觉得是不能界定为内存泄露的。