[TOC]



## 第1章　走入并行世界	1

> Give it up. The whole "parallel computing is the future" is a bunch of crock.

### 1.1　何去何从的并行计算 1

#### 1.1.1　忘掉那该死的并行	2

- BitKeeper真惨
- Git真好用
- 并行计算只有在图像处理和服务器编程2个领域可以使用

#### 1.1.2　可怕的现实：摩尔定律的失效	4

- CPU遇到了不可逾越的瓶颈

#### 1.1.3　柳暗花明：不断地前进	5

- CPU核心在不断变多

#### 1.1.4　光明或是黑暗	6

### 1.2　你必须知道的几个概念	6

#### 1.2.1　同步（Synchronous）和异步（Asynchronous）	7

- 见书中图

#### 1.2.2　并发（Concurrency）和并行（Parallelism）	8

- 并发是指宏观上在**一段时间内**能同时运行多个程序，而并行则指**同一时刻**能运行多个指令。

  <img src="https://raw.githubusercontent.com/scottie1996/PicGo/master/img/image-20201010170707947.png" alt="image-20201010170707947" style="zoom:67%;" />

#### 1.2.3　临界区	9
#### 1.2.4　阻塞（Blocking）和非阻塞（Non-Blocking）	9
#### 1.2.5　死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）	9

### 1.3　并发级别	11

#### 1.3.1　阻塞（Blocking）	11
#### 1.3.2　无饥饿（Starvation-Free）	11
#### 1.3.3　无障碍（Obstruction-Free）	12
#### 1.3.4　无锁（Lock-Free）	12
#### 1.3.5　无等待（Wait-Free）	13

### 1.4　有关并行的两个重要定律	13

#### 1.4.1　Amdahl定律	13
#### 1.4.2　Gustafson定律	16
#### 1.4.3　Amdahl定律和Gustafson定律是否相互矛盾	16

### 1.5　回到Java：JMM	17

并发编程时往往涉及三大性质：**原子性，有序性，可见性** 

JAVA 虚拟机模型涉及到线程安全问题一般是因为**主内存和工作内存数据不一致性**和**重排序**导致的，而解决线程安全的问题最重要的就是理解这两种问题是怎么来的，所以理解它们的核心在于理解java内存模型（JMM）。

### 内存模型抽象结构

并发编程中主要需要解决两个问题：

**1. 线程之间如何通信**

**2.线程之间如何完成同步**（这里的线程指的是并发执行的活动实体）。通信是指线程之间以何种机制来交换信息，主要有两种：**共享内存和消息传递**。java内存模型是**共享内存的并发模型**，线程之间主要通过读-写共享变量来完成隐式通信

共享变量：在java程序中所有**实例域，静态域和数组元素**都是放在堆内存中（所有线程均可访问到，是可以共享的），而局部变量，方法定义参数和异常处理器参数不会在线程间共享。**共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题**。关于JVM运行时内存区域在后面的文章会讲到。

<img src="https://raw.githubusercontent.com/scottie1996/PicGo/master/img/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="JMM内存模型的抽象结构示意图" style="zoom:50%;" />

在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到**多个线程间相互通信告知彼此的状态以及当前的执行结果**等，另外，为了性能优化，还会**涉及到编译器指令重排序和处理器指令重排序**。

#### 1.5.1　原子性（Atomicity）	18

原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。我们先来看看哪些是原子操作，哪些不是原子操作，有一个直观的印象：

```java
int a = 10; //1
a++; //2
int b=a; //3
a = a+1; //4
```

上面这四个语句中只**有第1个语句是原子操作**，将10赋值给线程工作内存的变量a,而语句2（a++）实际上包含了三个操作：1. 读取变量a的值；2：对a进行加一的操作；3.将计算后的值再赋值给变量a，而这三个操作无法构成原子操作。对语句3,4的分析同理可得这两条语句不具备原子性。当然，JMM中定义了8种操作都是原子的，不可再分的。

1. **lock(锁定)**：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；
2. **unlock(解锁)**:作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3. **read（读取）**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；
4. **load（载入）**：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本
5. **use（使用）**：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；
6. **assign（赋值）**：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；
7. **store（存储）**：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；
8. **write（操作）**：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。那么如何理解这些指令了?比如，把一个变量从主内存中复制到工作内存中就需要执行read,load操作，将工作内存同步到主内存中就需要执行store,write操作。注意的是：**java内存模型只是要求上述两个操作是顺序执行的并不是连续执行的**。也就是说read和load之间可以插入其他指令，store和writer可以插入其他指令。比如对主内存中的a,b进行访问就可以出现这样的操作顺序：**read a,read b, load b,load a**。

由原子性变量操作read,load,use,assign,store,write，可以**大致认为基本数据类型的访问读写具备原子性**（例外就是long和double的非原子性协定）





#### 1.5.2　可见性（Visibility）	20

回顾一下JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：

1. 线程A从主内存中**将共享变量读入线程A的工作内存**后并进行操作，之后将数据**重新写回**到主内存中；
2. 线程B**从主存中读取**最新的共享变量

从横向去看看，线程A和线程B就好像通过共享变量在进行隐式通信。这其中有常见的问题，如果线程A更新后数据并没有及时写回到主存，而此时线程B读到的是过期的数据，这就出现了“**脏读**”现象。可以通过同步机制(synchronized关键字)（控制不同线程间操作发生的相对顺序）来解决或者通过volatile关键字使得每次volatile变量都能够强制刷新到主存，从而对每个线程都是可见的。



#### 1.5.3　有序性（Ordering）	22

![从源码到最终执行的指令序列](https://raw.githubusercontent.com/scottie1996/PicGo/master/img/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%B0%E6%9C%80%E7%BB%88%E6%89%A7%E8%A1%8C%E7%9A%84%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97.png)

一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度(p23流水线的例子就是这样操作的 )。JMM对底层尽量减少约束，使其能够发挥自身优势。因此，在执行程序时，**为了提高性能，编译器和处理器常常会对指令进行重排序**。(**需要注意的是重排序只能保证串行语义一致，但是无法保证多线程间并行的语义也是一致的，这是破坏有序性的根本原因**。)一般重排序可以分为如下三种：

1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果**不存在数据依赖性**，处理器可以改变语句对应机器指令的执行顺序；
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。

如上图所示的过程中，1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题，一个很经典的例子就是DCL(单例模式的双重检查锁)问题。**针对编译器重排序**，JMM的编译器重排序规则会禁止一些**特定类型的编译器重排序**；**针对处理器重排序**，编译器在生成指令序列的时候会通过**插入内存屏障指令来禁止某些特殊的处理器重排序**。

##### 数据依赖性：

**如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性**这里就存在三种情况：1. 读后写；2.写后写；3. 写后读，者三种操作都是存在数据依赖性的，如果重排序会对最终执行结果会存在影响。**编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序**

##### as-if-serial语义

as-if-serial语义的意思是：不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。as-if-serial语义把单线程程序保护了起来，**遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的**。**as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。**



#### 1.5.4　哪些指令不能重排：Happen-Before规则	27

happens-before指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，**JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证**（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）

1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。

2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

上面的**1）是JMM对程序员的承诺**。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！

上面的**2）是JMM对编译器和处理器重排序的约束原则**。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。

##### **as-if-serial VS happens-before**

as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。

as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。

as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。



### 具体规则：

**程序次序规则**：在**一个线程内**一段代码的**执行结果是有序的**。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变！

**管程锁定规则**：就是无论是在单线程环境还是多线程环境，对于**同一个锁**来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果！(管程是一种通用的同步原语,synchronized就是管程的实现）

**volatile变量规则**：就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作的结果一定对读的这个线程可见。

**线程启动规则**：在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见。

**线程终止规则**：在主线程A执行过程中，子线程B终止，那么线程B在终止之前对共享变量的修改结果在线程A中可见。

**线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程代码检测到中断事件的发生，可以通过Thread.interrupted()检测到是否发生中断。

**传递规则**：这个简单的，就是happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C。

**对象终结规则**：这个也简单的，就是一个对象的初始化的完成，也就是构造函数执行的结束一定 happens-before它的finalize()方法。

这几条规则就是面向我们这些开发人员的，掌握了这几条规则能让我们更好的开发出符合我们预期的并发程序的代码！



### 1.6　参考文献	27