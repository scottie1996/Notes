## 键的过期时间

Redis是基于内存，内存是比较昂贵的，容量肯定比不上硬盘的。就我们现在一台普通的机子，可能就8G内存，但硬盘随随便便都1T了。

因为我们的内存是**有限**的。所以我们**会干掉不常用的数据，保留常用的数据**。这就需要我们设置一下键的过期(生存)时间了。

- 设置键的**生存**时间可以通过`EXPIRE`或者`PEXPIRE`命令。
- 设置键的**过期**时间可以通过`EXPIREAT`或者`PEXPIREAT`命令。

在redisDb结构体中还发现了`dict *expires;`属性，存放所有键过期的时间。



> redis > PEXPIREAT message 1391234400000 (integer) 1

![img](https://raw.githubusercontent.com/scottie1996/PicGo/master/img/640.jpeg)



既然有设置过期(生存)时间的命令，那肯定也有移除过期时间，查看剩余生存时间的命令了：

- PERSIST(移除过期时间)
- TTL(Time To Live)返回剩余生存时间，以秒为单位
- PTTL以毫秒为单位返回键的剩余生存时间

上面我们已经能够了解到：过期键是保存在哈希表中了。那这些过期键到了过期的时间，就会立马被删除掉吗？？

要回答上面的问题，需要我们了解一下删除策略的知识，删除策略可分为三种

- 定时删除(对内存友好，对CPU不友好)

- - 到时间点上就把所有过期的键删除了。

- 惰性删除(对CPU极度友好，对内存极度不友好)

- - 每次从键空间取键的时候，判断一下该键是否过期了，如果过期了就删除。

- 定期删除(折中)

- - **每隔**一段时间去删除过期键，**限制**删除的执行时长和频率。

Redis采用的是**惰性删除+定期删除**两种策略，所以说，**在Redis里边如果过期键到了过期的时间了，未必被立马删除的**！



## 内存淘汰机制

如果定期删除漏掉了很多过期key，也没及时去查(没走惰性删除)，大量过期key堆积在内存里，导致redis内存块耗尽了，咋整？

我们可以设置内存最大使用量，当内存使用量超出时，会施行**数据淘汰策略**。

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。redis 提供 6种数据淘汰策略：

- **volatile-lru**：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- **volatile-ttl**：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- **volatile-random**：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- **allkeys-lru**：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- **allkeys-random**：从数据集（server.db[i].dict）中任意选择数据淘汰
- **no-enviction**（驱逐）：禁止淘汰数据(但redis还会根据引用计数器进行释放呦~),这时如果内存不够时，会直接返回错误

![img](https://raw.githubusercontent.com/scottie1996/PicGo/master/img/640-20201129203646707)

### Redis回收进程如何工作的? Redis回收使用的是什么算法?

Redis中采用两种算法进行内存回收，引用计数算法以及LRU算法