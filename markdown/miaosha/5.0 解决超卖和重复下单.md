我们知道在**多线程写入同一个文件的时候，会存现“线程安全”的问题**（多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一样的，结果和预期相同，就是线程安全的）。**如果是MySQL数据库，可以使用它自带的锁机制很好的解决问题，但是，在大规模并发的场景中，是不推荐使用MySQL的**。**秒杀和抢购的场景中，还有另外一个问题，就是“超发”，如果在这方面控制不慎，会产生发送过多的情况**。我们也曾经听说过，某些电商搞抢购活动，买家成功拍下后，商家却不承认订单有效，拒绝发货。这里的问题，也许并不一定是商家奸诈，而是系统技术层面存在超发风险导致的。

## 解决超卖和重复下单

超卖场景：
**不同用户在读请求的时候，发现商品库存足够，然后同时发起请求，进行秒杀操作，减库存，导致库存减为负数。**

![image-20201213103503536](https://raw.githubusercontent.com/scottie1996/PicGo/master/img/image-20201213103503536.png)

### 方案一：采用乐观锁

乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断，算是一种CAS（Compare And Swep）操作，商品库存场景中number起到了版本控制（相当于version）的作用（ AND number=#{number}）。

使用乐观锁更新库存的时候不加锁，当提交更新时需要判断数据是否已经被修改（AND number=#{number}），只有在 number等于上一次查询到的number时 才提交更新。

**注意** ：UPDATE 语句的WHERE 条件字句上需要建索引

```sql
@Update("update auction_auctions set
stock_count = #inQuantity#
where goods_id=#{goodsId} and quantity = #dbQuantity#")
//存在ABA问题
```

![image-20201213103622651](https://raw.githubusercontent.com/scottie1996/PicGo/master/img/image-20201213103622651.png)

### 方案二：尝试扣减库存

```sql
//最简单的方法，更新数据库减库存的时候，进行库存限制条件，在reduceStock(GoodsVo goodsvo)这个方法里，sql要多加一个stock_count > 0即：
//stock_count>0的时候才去更新，数据库本身会有锁，那么就不会在数据库中同时多个线程更新一条记录，使用数据库特性来保证超卖的问题
	@Update("update miaosha_goods set stock_count=stock_count-1 where goods_id=#{goodsId} and stock_count>0")
	public void reduceStock(MiaoshaGoods goods);  
```

也可以对读操作加上显式的悲观锁锁（select … for update）这样一来用户1在进行读操作时用户2就需要排队等待了，但是如果商品很热门并发量很高那么效率就会大大的下降。

别忘记，**我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待“锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里**。同时，这种请求会很多，**瞬间增大系统的平均响应时间，结果是可用连接数被耗尽，系统陷入异常**。

## 解决同一用户重复下单

1. 在下订单的时候**判断是否重复秒杀**（我们限制一个用户只能秒杀一件商品，怎么判断？即从数据库根据商品和用户id **查询秒杀订单表**，如果已经存在订单，说明重复秒杀 ，给出提示，退出）
2. 在数据库的秒杀订单表里加一个唯一的索引,把用户和商品一起建了个唯一索引,唯一索引不可以有重复索引值，解决同一个用户重复下单的问题
3. 图形验证码防刷

